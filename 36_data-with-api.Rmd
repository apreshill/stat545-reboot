# Using an API to get data {#use-api}

In the simplest case, the data that you want is already available on the internet in a familiar format such as a csv and you can use `readr::read_csv()` to load it directly into R.

Often times, however, things are a bit more complicated. You might need to go through an [**Application Programming Interface**](https://en.wikipedia.org/wiki/Application_programming_interface#Web_APIs) (API) to get the data that you want.

An API allows you (the client) to programmatically get resources (e.g. a csv file, html file, etc.) from a web server via a [**Hypertext Transfer Protocol**](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) (HTTP) request. It is essentially facilitating a conversation: you send the web server a request and then the server sends you back a response. This response can either be the data you asked for or an error message.

![Image Source: [What exactly IS an API?](https://medium.com/@perrysetgo/what-exactly-is-an-api-69f36968a41f)  by Perry Eising](img/api-diagram.png)

If an API is popular, it might have an API wrapper package that will handle the HTTP part for you. If not, then you will need to handle the HTTP part yourself. This isn't as bad as it may seem! The [`httr`][httr-web] package (on [CRAN][httr-cran], on [GitHub][httr-github]) can help make this easier.

If you are interested in learning more about APIs and HTTP check out Chapter \@ref(api-resources) for some good places to start.


## Install-and-play {#api-wrappers}

Many popular APIs have helper R packages that "wrap" around the original API. These packages generally will have functions that assist with formatting a query, sending the query to the web server, and parsing the response sent back.

The first thing that you should do if you're planning on using an API to get data is to see if there is already an API wrapper package that exists. Try searching the API name on CRAN and GitHub. If there is an API wrapper package available, you should definitely try to use it. 

Here are a few popular API wrapper packages for APIs that you may have heard of (see Chapter \@ref(api-resources) for more):

* [`rtweet`](https://rtweet.info) for the Twitter API (on [CRAN](https://CRAN.R-project.org/package=rtweet), on [GitHub](https://github.com/mkearney/rtweet))
* [`gutenbergr`](https://docs.ropensci.org/gutenbergr/) for Project Gutenberg's API (on [CRAN](https://CRAN.R-project.org/package=gutenbergr), on [GitHub](https://github.com/ropensci/gutenbergr))
* [`gistr`](https://docs.ropensci.org/gistr/) for GitHub gists (on [CRAN](https://CRAN.R-project.org/package=gistr), on [GitHub](https://github.com/ropensci/gistr))

### Exploring Headcount of Homeschooled Children in British Columbia with `bcdata` {#bcdata}

The [British Columbia Data Catalogue](https://catalogue.data.gov.bc.ca/dataset) contains thousands of B.C. government datasets that are available under the [Open Government License - British Columbia](https://www2.gov.bc.ca/gov/content/data/open-data/open-government-licence-bc). From searching "B.C. Data Catalogue CRAN" on google I found an R package called [`bcdata`](https://bcgov.github.io/bcdata/) (on [GitHub](https://github.com/bcgov/bcdata)) that is a wrapper for the B.C. Data Catalogue.

The record that we will explore is the ["Headcount of Homeschooled Children"](https://catalogue.data.gov.bc.ca/dataset/headcount-of-homeschooled-children), which contains data about the number of homeschooled children in B.C. registered between 1991 and 2018. Our end goal is to visualize how the headcounts varies between male and female students across all of B.C. over the school years. The first step is to get the data into R. We can use the `bcdata` wrapper package to help us with this.

Install the package from GitHub (only do once)...

```r
library(remotes)
remotes::install_github("bcgov/bcdata")
```

...and then load it.

```{r}
library(bcdata)
```

The `bcdata` [website](https://bcgov.github.io/bcdata/) gives an overview of the main functions in the package. The ones that we will use are:

* `bcdc_browse()` - to browse the B.C. Data Catalogue (opens in your default browser)
* `bcdc_get_record()` - returns the catalogue record
* `bcdc_get_data()` - get the data for a catalogue record

There is also a [Get Started](https://bcgov.github.io/bcdata/articles/bcdata.html) vignette that is a good starting point for getting familiar with this package. We will loosely follow along with this vignette to get the "Headcount of Homeschooled Children" record data. 

First, we will use the [`bcdc_browse()`](https://bcgov.github.io/bcdata/reference/bcdc_browse.html) function to open up the B.C. Data Catalogue in our browser and find the webpage for the "Headcount of Homeschooled Children" record.

```r
bcdc_browse()
```
You can filter the results by format type (e.g. csv files, xls files) and also search for keywords. Searching for "homeschool" will lead us to the "Headcount of Homeschooled Children" record [page](https://catalogue.data.gov.bc.ca/dataset/headcount-of-homeschooled-children). 

Under the Data and Resources section on this page we can see that there are six files available. Let's figure out how to get the first csv into R. 

We can use `bcdc_get_data()` to pull down the file into R. Take a look at the documentation for this function [here](https://bcgov.github.io/bcdata/reference/bcdc_get_data.html) or by typing `?bcdc_get_data` in your console. 

This function has one required argument, `record`, which can be the output of `bcdc_get_record()`, the resource name or ID as a string, or the resource URL. Let's use the resource URL. 

On the record [webpage](https://catalogue.data.gov.bc.ca/dataset/headcount-of-homeschooled-children) there is a "Show the Permalink" button. [Permalink](https://en.wikipedia.org/wiki/Permalink) is short for permanent link and is exactly what it sounds like: a link that will most likely not change. If you click on this button it will change the url to the permalink: `https://catalogue.data.gov.bc.ca/dataset/d378b0ba-6fa2-4f7f-a08c-97c697979ec3`. Save this as a string called `url`.

```{r}
url <- "https://catalogue.data.gov.bc.ca/dataset/d378b0ba-6fa2-4f7f-a08c-97c697979ec3"
```

We aren't quite ready to run `bcdc_get_data()` yet, however. There is also an optional argument, `resource`, which is used for cases when a record has multiple files available. Our record has six files available so we will definitely need to supply a `resource` argument. In the examples section of the [`bcdc_get_data()` documentation](https://bcgov.github.io/bcdata/reference/bcdc_get_data.html) we see that the resource ID is what we need to pass to `resource`. 

Where do we get the resource ID from? This isn't quite clear in the `bcdc_get_data()` documentation so we might need to explore a bit. Let's start by looking at the `bcdc_get_record()` function that was mentioned earlier. 

Take a look at the documentation for `bcdc_get_record()` [here](https://bcgov.github.io/bcdata/reference/bcdc_get_record.html) or by typing `?bcdc_get_record` in your console. It takes one argument, `id`, which can be the record URL. Let's pass it the permalink url that we saved earlier and see what we get back.

```{r}
bcdc_get_record(url)
```

This has the information that we were looking for! It lists six resources in total, the first one is a csv file called `Headcount_Homeschool`. This is the one we want. The resource ID is listed under "resource".

```
1) Headcount_Homeschool
     format: csv 
     url: https://catalogue.data.gov.bc.ca/dataset/d378b0ba-6fa2-4f7f-a08c-97c697979ec3/resource/409faf5a-7bf9-4d3f-baf6-758e0892a9c6/download/headcount_homeschool.csv 
     resource: 409faf5a-7bf9-4d3f-baf6-758e0892a9c6
     available in R via bcdata:  TRUE 
     code: bcdc_get_data(record = 'd378b0ba-6fa2-4f7f-a08c-97c697979ec3', resource = '409faf5a-7bf9-4d3f-baf6-758e0892a9c6')
```

Copy-and-paste the resource ID and save it as a string called `resource_id`.

```{r}
resource_id <- "409faf5a-7bf9-4d3f-baf6-758e0892a9c6"
```

Now we are ready to call `bcdc_get_data()` and read in the csv file.

```{r}
homeschool_data <- bcdc_get_data(record = url, resource = resource_id)
```

Yikes. We get a warning saying that there were 14,750 parsing failures. Only the first five parsing failures are printed out here but we can see that the failures started at row 2,974. It looks like a some of the failures occurred because a logical (TRUE/FALSE) was expected but the actual row value was an integer or a string. 

The output told us that it was using `readr::read_csv()` to read in the file. From previous use I know that `read_csv()` has an argument called `guess_max`, which is the maximum number of rows that are used to guess the column type (we haven't covered this so don't worry if this is uncharted territory for you). Remember that our parsing failures started at row 2,974, so let's see if setting `guess_max = 3000` helps.

How do we pass `guess_max = 3000` to the `readr::read_csv()` call?

Let's go back to the `bcdc_get_data` documentation ([here](https://bcgov.github.io/bcdata/reference/bcdc_get_data.html) or by typing `?bcdc_get_data` in your console). 

Under the Arguments section we learn that `...` corresponds to arguments that are passed to the function that handles reading in the data file so we can just add `guess_max = 3000` as a third argument to our `bcdc_get_data()` call.  

```{r}
homeschool_data <- bcdc_get_data(record = url, resource = resource_id, guess_max = 3000)
```

No parsing failures! Now let's check out this data.

```{r message = FALSE}
library(dplyr)
glimpse(homeschool_data)
```

To find out what the column names mean we need to examine the original [record webpage](https://catalogue.data.gov.bc.ca/dataset/headcount-of-homeschooled-children) to locate the data dictionary. The data dictionary is [here](https://catalogue.data.gov.bc.ca/dataset/headcount-of-homeschooled-children/resource/aa05b182-e655-4b0f-8da6-af954b374c79). 


The `DATA_LEVEL` column specifies whether an observation is at the district-, province-, or school-level. The possible values are "PROVINCE LEVEL", "DISTRICT LEVEL", and "SCHOOL LEVEL". We want to look at headcounts across all of B.C. so we need to filter out data to only keep the observations that are at the province-level.

```{r}
homeschool_province <- homeschool_data %>% 
  filter(DATA_LEVEL == "PROVINCE LEVEL")

glimpse(homeschool_province)
```

From the data dictionary we also learn that the `PUBLIC_OR_INDEPENDENT` column splits the headcounts by whether the child was registered at a public school or an independent school. It has three values:

  * `BC Public School`
  * `BC Independent School`
  * `PROVINCE - Total` (the sum of the `BC Public School` and `BC Independent School` values)
  
We want to look at headcount differences between male and female, not between registration types, so let's filter our data and keep only the `PROVINCE - Total` rows. 

```{r}
homeschool_province2 <- homeschool_province %>% 
  filter(PUBLIC_OR_INDEPENDENT == "PROVINCE - Total") 

glimpse(homeschool_province2)
```

There are a few final things that we need to do before we can start plotting. The headcounts for males and females are in an un-tidy format. Let's reshape the data by using `tidyr::gather()` that we learned about in Chapter \@ref(tidy-data) to gather the `MALE_HOME_SCHOOL_COUNT` and `FEMALE_HOME_SCHOOL_COUNT` columns into `gender` and `headcount`. Then we will use `dplyr::case_when()` to rename `MALE_HOME_SCHOOL_COUNT` and `FEMALE_HOME_SCHOOL_COUNT` to `male` and `female` (we haven't used this function yet so don't worry if this is new territory for you, this is just to make things neater). 

```{r}
library(tidyr)

homeschool_tidy <- homeschool_province2 %>% 
  gather(MALE_HOME_SCHOOL_COUNT, FEMALE_HOME_SCHOOL_COUNT, key = "gender", 
         value = "headcount") %>% 
  mutate(gender = case_when(gender == "FEMALE_HOME_SCHOOL_COUNT" ~ "female",
                            gender == "MALE_HOME_SCHOOL_COUNT" ~ "male"))

glimpse(homeschool_tidy)
```

Great! Now let's plot the headcounts of homeschooled males and females over the school years.

```{r fig.pos = "center"}
library(ggplot2)

ggplot(homeschool_tidy, aes(x = SCHOOL_YEAR, y = headcount, 
                            color = gender, group = gender)) +
  geom_point() +
  geom_line() +
  # clean up axis title and plot title
  labs(x = "School Year", y = "Total Homeschooled Children",
       title = "Headcounts of Homeschooled Children in British Columbia by Gender",
       caption = "Data Source: B.C. Data Catalogue") +
  # this changes the angle of the x axis labels 
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

Interesting, there were more male children than female children that were homeschooled in B.C. for all schools years except 1994/1995. The number of children homeschooled also peaked in the 1996/1997 school year and steadily decreased after. Maybe there was something that happened in 1996/1997 that sparked this decline.

If you want to keep going, try visualizing the headcounts of homeschooled children over the school years (regardless of gender) for registrations at Public School vs Independent Schools.

## Interact with an API {#api-query}

In Chapter \@ref(api-wrappers) we experimented with several packages that "wrapped" APIs. API wrapper packages handle the creation of the request and the parsing of the output. What do you do if you want to use an API in R that doesn't already have a wrapper package written for it? One option is using the [`httr`][httr-web] package (on [CRAN][httr-cran], on [GitHub][httr-github]) to help out with the HTTP requests and responses. 

The [Getting started with `httr`](https://httr.r-lib.org/articles/quickstart.html) vignette is a good place to start if you haven't used the `httr` package before. 

The main functions in `httr` that we will be using are:

* [`GET()`](https://httr.r-lib.org/reference/GET.html) - sends a request to a `url` with `config` settings that you specify and returns a `response` object
* [`content()`](https://httr.r-lib.org//reference/content.html) - returns the body of a response object (more on this later)

A `response` object contains all of the information associated with a request. You can pull up the documentation for `response` by calling `?response` in your console. Some of the fields that a `response` object will have include:

* `url` - where the request was sent (i.e. the url passed to `GET()`)
* `status_code` - the HTTP status code request/response
* `header` - a named list of the headers in the response 

We will talk more about the specifics of all of this when we walk through an example of using `httr` to query the [Open Movie Database](http://www.omdbapi.com) (OMBD) API in the following section.

Before that, however, there is one more layer to querying an API that we need to address: the format of the response sent back by the web server. A good API wrapper package will spare you the pain of parsing the response and hand you the data all neat and cleaned up. We won't be as lucky this time around. 

The two most common formats that you will encounter are [JSON](https://www.json.org) and [XML](https://en.wikipedia.org/wiki/XML), which stand for JavaScript Object Notation and Extensible Markup Language respectively. JSON is a ["lightweight data-interchange format"](https://www.json.org) and XML is a data format and also a markup language. Both are used to store and transfer data on the web. There is the [`jsonlite`][jsonlite-cran] package for handling JSON in R and the [`xml2`][xml2-web] package for handling XML in R.

We will be focusing mainly on XML in this chapter but I recommend starting with [JSON vs XML](https://restfulapi.net/json-vs-xml/) and [json.org](https://www.json.org) to learn more about both. 

Next up: using `httr` to query the [Open Movie Database](http://www.omdbapi.com) (OMBD) API and `xml2` to parse the response!

### Getting movie data with the OMDb API

The [Open Movie Database](http://www.omdbapi.com) (OMDb) is an API that you can use to get data about movies and movie posters. <!--CC BY-NC 4.0-->We won't be using an API wrapper package to get data via this API so we will need to read the OMDb documentation to find out how to use it. 

Looking through [omdbapi.com](http://www.omdbapi.com) we find out that in order to interact with this API we will need to request an API key. An API key is used to track how an API is being used. It is a secret, unique identifier that is associated with a request(s). They are often used to limit the number of requests that someone is sending. For example, the OMDb API has a 1,000 daily request limit. You can read more about API keys in the `httr` vignette [Managing secrets](https://httr.r-lib.org/articles/secrets.html).

Request a free API key for the OMDb API here: <http://www.omdbapi.com/apikey.aspx> 

Check your email and follow the instructions to activate your key. This email should include your key, which will be a mix of letters and digits.

Now that you have an API key, the next step is to put it somewhere that you (or an API wrapper package, etc.) can access. Your API key should be kept secret so we need make sure we put it somewhere safe. One option is to stash it in your .Renviron file. Be sure to save it as something memorable, like `OMDB_API_KEY`. You can use the `edit_r_environ()` function from the `usethis` package to add it to your `.Renviron` file.

```r
library(usethis)

usethis::edit_r_environ() # edit your user level.Renviron file.
```
This will open up your .Renviron file in a new tab. Add `OMDB_API_KEY=<your-secret-api-key>` on a new line (be sure to add a new line after this).

Save the file and restart your R session (Session -> Restart R). You can now access your key whenever you want by calling `Sys.getenv("OMDB_API_KEY")`. __Note!__ If you are using GitHub you may want to add `.Renviron` to your `.gitignore` file so you don't accidentally push the key that you just took the time to hide.


* brief review of available functions
* pull down Harry Potter and the Prisoner of Azkaban the movie poster
* pull down Harry Potter and the Prisoner of Azkaban metadata
  + returns an xml doc
* main xml2 functions
* parse xml response


```{r links, child="links.md"}
```



