# Using an API to get data {#use-api}

In the simplest case, the data you need is already on the internet in a tabular format. In these cases you could use `read.csv()` or `readr::read_csv()` to read the data straight into R. 

<!--If you're lucky, the data that you want is neatly packaged in a familiar format such as a csv or xls and you can download and read directly into R. -->

Often times, however, things are a bit more complicated and you might need to go through an [**Application Programming Interface**](https://en.wikipedia.org/wiki/Application_programming_interface#Web_APIs) (API) to get the data that you want.
18
An API allows you (the client) to programmatically get resources (e.g. a csv file, html file, etc.) from a web server via a [**Hypertext Transfer Protocol**](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) (HTTP) request. 

![Image Source: https://medium.com/@perrysetgo/what-exactly-is-an-api-69f36968a41f](img/api-diagram2.png)

Sometimes an API will have an API wrapper package that will handle the HTTP part for you. Sometimes you will have to handle the HTTP part yourself. In the latter cases, the [`httr`](https://CRAN.R-project.org/package=httr) package is a great resource to use.

Many sources of data – databases, websites, services – have made all (or part) of their data available via APIs over the internet. Computer programs (“clients”) can make requests of the server, and the server will respond by sending data (or an error message). This client can be many kinds of other programs or websites, including R running from your laptop.

There is a lot more to API's and HTTP that we won't cover. If you're interested in learning more these are some good resources to check out:

  * A very thorough explanation of API's: https://medium.com/@perrysetgo/what-exactly-is-an-api-69f36968a41f
  * Lucy D'Agostino McGowan's "Harnessing the Power of the Web via R Clients for Web APIs" [here](https://www.lucymcgowan.com/talk/asa_joint_statistical_meeting_2018/)
  * ["HTTP: The Protocol Every Web Developer Must Know"](https://code.tutsplus.com/tutorials/http-the-protocol-every-web-developer-must-know-part-1--net-31177)


## Install-and-play {#api-wrappers}

Many common web services and APIs have been “wrapped”, i.e. R functions have been written around them which send your query to the server and format the response.

Why do we want this?

* provenance
* reproducible
* updating
* ease
* scaling

The first thing that you should do if you're planning on using an API to get data is to see if there is already an API wrapper package that exists. Try searching the API name on CRAN and GitHub. Most popular API's will likely have an API wrapper package available that will make your life so much easier. 

Here are a few popular API wrapper packages that you may have heard of (see _resources_ for more):

* [`rtweet`](https://rtweet.info): on [CRAN](https://CRAN.R-project.org/package=rtweet), on [GitHub](https://github.com/mkearney/rtweet)
* [`gutenbergr`](https://docs.ropensci.org/gutenbergr/): on [CRAN](https://CRAN.R-project.org/package=gutenbergr), on [GitHub](https://github.com/ropensci/gutenbergr)
* [`gistr`](https://docs.ropensci.org/gistr/): on [CRAN](https://CRAN.R-project.org/package=gistr), on [GitHub](https://github.com/ropensci/gistr)
* [`rplos`](https://docs.ropensci.org/rplos/): on [CRAN](https://CRAN.R-project.org/package=rplos), on [GitHub](https://github.com/ropensci/rplos)
* [`googleLanguageR`](http://code.markedmondson.me/googleLanguageR/): on [CRAN](https://CRAN.R-project.org/package=googleLanguageR), on [GitHub](https://github.com/ropensci/googleLanguageR)
* [`aRxiv`](https://docs.ropensci.org/aRxiv/): on [CRAN](https://CRAN.R-project.org/package=aRxiv), on [GitHub](https://github.com/ropensci/aRxiv)
* [`rnoaa`](https://ropensci.org/tutorials/rnoaa_tutorial/): on [CRAN](https://CRAN.R-project.org/package=rnoaa), on [GitHub](https://github.com/ropensci/rnoaa)


### Exploring Headcount of Homeschooled Children in British Columbia with `bcdata` {#bcdata}

The [British Columbia Data Catalogue](https://catalogue.data.gov.bc.ca/dataset) contains thousands of B.C. government datasets that are available under the [Open Government License - British Columbia](https://www2.gov.bc.ca/gov/content/data/open-data/open-government-licence-bc). From searching "B.C. Data Catalogue CRAN" on google I found the an R package called [`bcdata`](https://bcgov.github.io/bcdata/) (on [GitHub](https://github.com/bcgov/bcdata)) that is a wrapper for the B.C. Data Catalogue.

The record that we will explore is the ["Headcount of Homeschool Children"](https://catalogue.data.gov.bc.ca/dataset/headcount-of-homeschooled-children) which contains data about the number of homeschool children registered between 1991 and 2018. Let's visualize how the headcounts varies between male and female students.

We can use the `bcdata` package to get the data into our R session. First, let's install the package from GitHub (only do once) and then load it.

```r
library(remotes)
remotes::install_github("bcgov/bcdata")
```

```{r}
library(bcdata)
```


The `bcdata` [website](https://bcgov.github.io/bcdata/) gives us a nice overview of the main functions in the package and tells us that there is a  ["Get started" vignette](https://bcgov.github.io/bcdata/articles/bcdata.html) available. This vignette seems like it would be a good starting point to get familiar with this package. Let's follow along and load in some data to explore.

First, we will use the [`bcdc_browse()`](https://bcgov.github.io/bcdata/reference/bcdc_browse.html) function to open up the B.C. Data Catalogue in our browser and find a record that we are interested in.

```r
bcdc_browse()
```

You can filter the results by format type (e.g. .csv, .xls) and also search for keywords. Let's explore the record titled ["Headcount of Homeschool Children"](https://catalogue.data.gov.bc.ca/dataset/headcount-of-homeschooled-children). In the Data and Resources section of the webpage we can see that there are six files available. Let's figure out how to get the first csv into R. 


In the `bcdata` package [vignette](https://bcgov.github.io/bcdata/articles/bcdata.html) they use the `bcdc_get_data()` function to pull down a dataset. Take a look at the documentation for this function [here](https://bcgov.github.io/bcdata/reference/bcdc_get_data.html) or by typing `?bcdc_get_data` in your console. 

This function has one required argument, `record`, which can be the output of `bcdc_get_record()`, the resource name or ID as a string, or the resource URL. Let's use the resource URL. On the record [webpage](https://catalogue.data.gov.bc.ca/dataset/headcount-of-homeschooled-children) there is a "Show the Permalink" button. [Permalink](https://en.wikipedia.org/wiki/Permalink) is short for permanent link and is pretty much exactly what it sounds like, a link that will most likely not change. If you click on this button it will change the url to the permalink: `https://catalogue.data.gov.bc.ca/dataset/d378b0ba-6fa2-4f7f-a08c-97c697979ec3`. Let's save this as a string called `url` pass to `bcdc_get_data()`. 

```{r}
url <- "https://catalogue.data.gov.bc.ca/dataset/d378b0ba-6fa2-4f7f-a08c-97c697979ec3"
```

We aren't quite ready to run `bcdc_get_data()` yet, however. There is also an optional argument, `resource`, which is used for cases when a record has multiple files available. Our record has six files available so we will definitely need to supply a `resource` argument. In the examples section of the documentation we see that the resource ID is what we need to pass to `resource`. 

Where do we get the resource ID from? It isn't quite clear in the `bcdc_get_data()` [documentation](https://bcgov.github.io/bcdata/reference/bcdc_get_data.html) so we might need to explore a bit. Let's start by looking at the `bcdc_get_record()` function that was mentioned earlier. 

Take a look at the documentation for `bcdc_get_record()` [here](https://bcgov.github.io/bcdata/reference/bcdc_get_record.html) or by typing `?bcdc_get_record` in your console. It takes one argument, `id`, which can be the record URL. Let's see what it returns.

```{r}
bcdc_get_record(url)
```

This has the information that we were looking for! It lists six resources in total, the first one is a csv file called `Headcount_Homeschool`. This is the one we want. The resource ID is listed under "resource".

```
1) Headcount_Homeschool
     format: csv 
     url: https://catalogue.data.gov.bc.ca/dataset/d378b0ba-6fa2-4f7f-a08c-97c697979ec3/resource/409faf5a-7bf9-4d3f-baf6-758e0892a9c6/download/headcount_homeschool.csv 
     resource: 409faf5a-7bf9-4d3f-baf6-758e0892a9c6
     available in R via bcdata:  TRUE 
     code: bcdc_get_data(record = 'd378b0ba-6fa2-4f7f-a08c-97c697979ec3', resource = '409faf5a-7bf9-4d3f-baf6-758e0892a9c6')
```

Let's copy-and-paste the resource ID and save it as a string called `resource_id`.

```{r}
resource_id <- "409faf5a-7bf9-4d3f-baf6-758e0892a9c6"
```

Now we are ready to run `bcdc_get_data()` and read in the csv file!

```{r}
homeschool_data <- bcdc_get_data(record = url, resource = resource_id)
```

Yikes, we get a warning saying that there were 14,750 parsing failures. Only the first five parsing failures are printed out here but we can see that the failures started at row 2,974. It looks like a some of the failures occured because a logical (TRUE/FALSE) was expected but the actual row value was an integer or a string. To fix this first we need to figure out how `bcdc_get_data()` handles reading in files. Let's so back to the documentation (online [here](https://bcgov.github.io/bcdata/reference/bcdc_get_data.html) or by typing `?bcdc_get_data` in your console). 

Under the Arguments section we learn that `...` corresponds to arguments that are passed to the function that handles reading in the data file and that we can use `bcdc_read_functions()` to see what these functions are. 

```{r}
bcdc_read_functions()
```

From this we see that csv files are imported using `readr::read_csv()`. From previous use I know that `read_csv()` has an argument called `guess_max`, which is the maximum number of rows that are used to guess the column type (we haven't covered this earlier so don't worry if this is uncharted territory for you). Remember that our parsing failures started at row 2,974, so let's see if setting `guess_max = 3000` helps.

```{r}
homeschool_data <- bcdc_get_data(record = url, resource = resource_id, guess_max = 3000)
```

No parsing failures! Phew. Now let's check out this data.

```{r message = FALSE}
library(dplyr)

glimpse(homeschool_data)
```

To find out what the column names mean we need to examine the [record webpage](https://catalogue.data.gov.bc.ca/dataset/headcount-of-homeschooled-children) to locate the data dictionary. The data dictionary is [here](https://catalogue.data.gov.bc.ca/dataset/headcount-of-homeschooled-children/resource/aa05b182-e655-4b0f-8da6-af954b374c79). 


The `DATA_LEVEL` column specifies whether an observation is at the district-, province-, or school-level. We're want to look at headcounts across all of B.C. so we need to filter out data to only keep the observations at the province-level.

```{r}
homeschool_province <- homeschool_data %>% 
  filter(DATA_LEVEL == "PROVINCE LEVEL")

glimpse(homeschool_province)
```


From the data dictionary we also learn that the `PUBLIC_OR_INDEPENDENT` column splits the headcounts by whether the child was registered at a public school or an independent school. It has three values:

  * `BC Public School`
  * `BC Independent School`
  * `PROVINCE - Total`: the sum of the `BC Public School` and `BC Independent School` values
  
We want to look at headcount differences between male and female, not between registration types, so let's filter our data and keep only the `PROVINCE - Total` rows. 

```{r}
homeschool_province2 <- homeschool_province %>% 
  filter(PUBLIC_OR_INDEPENDENT == "PROVINCE - Total") 

glimpse(homeschool_province2)
```

There are a few final things that we need to do before we can start plotting. The headcounts for males and females are in an un-tidy format. Let's reshape the data by using `tidyr::gather()` that we learned about in Chapter __insert-ref__ to gather the `MALE_HOME_SCHOOL_COUNT` and `FEMALE_HOME_SCHOOL_COUNT` columns into `gender` and `headcount`. Then, we will use `dplyr::case_when()` to rename `MALE_HOME_SCHOOL_COUNT` and `FEMALE_HOME_SCHOOL_COUNT` to `male` and `female` (we haven't used this function yet so don't worry if this is new territory for you, this is just to make things neater). 

```{r}
library(tidyr)
library(forcats)

homeschool_tidy <- homeschool_province2 %>% 
  gather(MALE_HOME_SCHOOL_COUNT, FEMALE_HOME_SCHOOL_COUNT, key = "gender", value = "headcount") %>% 
  mutate(gender = case_when(gender == "FEMALE_HOME_SCHOOL_COUNT" ~ "female",
                            gender == "MALE_HOME_SCHOOL_COUNT" ~ "male"))

glimpse(homeschool_tidy)
```

Great! Now let's plot the headcounts of homeschooled males and females over the school years.

```{r}
library(ggplot2)

ggplot(homeschool_tidy, aes(x = SCHOOL_YEAR, y = headcount, 
                            color = gender, group = gender)) +
  geom_point() +
  geom_line() +
  
  # clean up axis title and plot title
  labs(x = "School Year", y = "Total Homeschooled Children",
       title = "Headcounts of Homeschooled Children in British Columbia by Gender",
       caption = "Data Source: B.C. Data Catalogue") +
  
  # this changes the angle of the x axis labels 
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```


Interesting, there were more male children than female children that were homeschooled in B.C. for all schools years except 1994/1995. The number of children homeschooled also peaked in the 1996/1997 school year and steadily decreased after.
### Exploring US census data using `tidycensus` {#tidycensus}

The [`tidycensus`][tidycensus-web] package (on [CRAN][tidycensus-cran], on [GitHub][tidycensus-github]) is a wrapper package for two US Census Bureau API's:

* [Decennial Census (1990, 2000, 2010) API](https://www.census.gov/data/developers/data-sets/decennial-census.html)
* [American Community Survey 5-Year Data (2009-2017) API](https://www.census.gov/data/developers/data-sets/acs-5year.html)

The authors have written a great vignette to help get you started with `tidycensus` [here](https://walkerke.github.io/tidycensus/articles/basic-usage.html).

First, let's install/load the package.
```{r message = FALSE}
#install.packages("tidycensus")
library(tidycensus)
```

To access the US Census Bureau API's first we need to request a new API key here: <https://api.census.gov/data/key_signup.html>. Check your email and follow the instructions to activate your key.

Now that you have a personal API key, the next step is to add it to your .Renviron file. The `tidycensus` package has a helpful function called `census_api_key()` that will take care of this step for you but we can also do it ourselves with the `usethis` package.

```r
library(usethis)

usethis::edit_r_environ() # edit your user level.Renviron file.
```

This will open up your .Renviron file in a new tab. Add `CENSUS_API_KEY=<your-secret-api-key>` on a new line. Be sure to add a new line after this! <!--insert photo of RStudio default setting here--> 

Save the file and restart your R session. You can now access your key with `Sys.getenv("CENSUS_API_KEY")`. If you are using GitHub be sure to add `.Renviron` to your `.gitignore` file so you don't accidentally push the key that you just took the time to hide.

Let's try pulling in some data from the [1990 Decennial Census](https://www.census.gov/data/developers/data-sets/decennial-census.1990.html). We can check out the different variables for one of the datasets through the US Census Bureau [website](https://api.census.gov/data/1990/sf3/variables.html) or with `tidycensus::load_variables()`.

```{r}
library(dplyr)

# what are the variables for the sf3 dataset for 1990?
variables_1990 <- load_variables(1990, "sf3")
glimpse(variables_1990)
```


Let's explore variables related to income. We can filter for labels that contain the string "income" by combining `stringr::str_detect()` with `dplyr::filter()`.
```{r}
library(stringr)

variables_1990 %>% 
  mutate(label = str_to_lower(label)) %>%  # eliminate case sensitivity problems
  filter(str_detect(label, "income"))
```

What was the median household income in 1990 by state? Let's use `tidycensus::get_decennial()` to pull down the relevant data.
```{r}
median_income <- get_decennial(geography = "state", variables = "P080A001", 
                               year = 1990) %>% 
  rename(state = NAME)

glimpse(median_income)
```

Hmm, there are 51 observations instead of 50. Maybe this is because they separated DC?
```{r}
median_income %>% 
  mutate(state = str_to_lower(state)) %>% # eliminate case sensitivity problems
  filter(state %in% c("dc", "d.c.", "district of columbia")) # check a few variations
```
It looks like they did!

Let's try plotting.
```{r fig.width = 9, fig.height = 9}
library(ggplot2)

ggplot(median_income, aes(state, value)) +
  geom_point(color = "cornflowerblue", alpha = 0.8) +
  labs(x = "State", y = "Median Household Income", 
       title = "1990 US Decennial Census Data",
       subtitle = "Median Household Income by State",
       caption = "Data Source: https://www.census.gov") +
  scale_y_continuous(breaks = c(20000, 25000, 30000, 35000, 40000, 45000),
                     labels = c("$20,000", "$25,000", "$30,000", "$35,000",
                                "$40,000", "$45,000")) +
  coord_flip() +
  theme_minimal()
```

Whoops. Let's use `forcats::fct_reorder` to reorder the factor levels of `state` to make this plot easier to parse.
```{r}
library(forcats)

median_income_ordered <- median_income %>% 
  mutate(state = fct_reorder(state, value))
```

```{r fig.width = 9, fig.height = 9}
ggplot(median_income_ordered, aes(state, value)) +
  geom_point(color = "cornflowerblue", alpha = 0.8) +
  labs(x = "State", y = "Median Household Income", 
       title = "1990 US Decennial Census Data",
       subtitle = "Median Household Income by State",
       caption = "Data Source: United States Census Bureau") +
  scale_y_continuous(breaks = c(20000, 25000, 30000, 35000, 40000, 45000),
                     labels = c("$20,000", "$25,000", "$30,000", "$35,000",
                                "$40,000", "$45,000")) +
  coord_flip() +
  theme_minimal()
```

The states with the highest median household income in 1990 were Connecticut, Alaska, and New Jersey while those with the lowest were Arkansas, West Virginia, and Mississippi. Is it what you were expecting to see?


## Interact with an API

In Chapter \@ref(api-wrappers) we experimented with several packages that "wrapped" APIs. That is, they handled the creation of the request and the formatting of the output. What do you do if you want to use an API in R that doesn't already have a wrapper package written for it? One option is using the `httr` package to help out with the 




First we're going to examine the structure of API requests via the [Open Movie Database](https://www.omdbapi.com/) (OMDb). OMDb is very similar to IMDB, except it has a nice, simple API. We can go to the website, input some search parameters, and obtain both the XML query and the response from it. 

### Exploring movies using the OMDb API


The [Open Movie Database](http://www.omdbapi.com) (OMDb) is an API for movies. <!--CC BY-NC 4.0--> Before we can interact with this API in R we need to request an API key. 

request a free API key (1,000 daily request limit) here: http://www.omdbapi.com/apikey.aspx



```{r links, child="links.md"}
```



