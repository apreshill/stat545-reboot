# Using an API to get data {#use-api}

In the simplest case, the data that you want is already available on the internet in a familiar format such as a csv and you can use `readr::read_csv()` to load it directly into R.

Often times, however, things are a bit more complicated. You might need to go through an [**Application Programming Interface**](https://en.wikipedia.org/wiki/Application_programming_interface#Web_APIs) (API) to get the data that you want.

An API allows you (the client) to programmatically get resources (e.g. a csv file, html file, etc.) from a web server via a [**Hypertext Transfer Protocol**](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) (HTTP) request. You send the web server a request and then the server sends you back a response. This response can be the data you asked for or an error message.

![Image Source: [What exactly IS an API?](https://medium.com/@perrysetgo/what-exactly-is-an-api-69f36968a41f)  by Perry Eising](img/api-diagram.png)

If an API is popular, it might have an API wrapper package that will handle the HTTP part for you. If not, then you will have to handle the HTTP part yourself. For the latter cases, you don't need to do it entirely by yourself! The [`httr`][httr-web] package (on [CRAN][httr-cran], on [GitHub][httr-github]) can help make this less painful. 

There's a lot more to APIs and HTTP that we won't cover in this chapter. Check out Chapter \@ref(api-resources) for some good resources if you're interested in learning more.


## Install-and-play {#api-wrappers}

Many popular APIs have helper R packages that "wrap" around the original API. These packages generally will have functions that assist with formatting a query, sending the query to the web server, and parsing the response sent back.

The first thing that you should do if you're planning on using an API to get data is to see if there is already an API wrapper package that exists. Try searching the API name on CRAN and GitHub. If there is an API wrapper package available then you should definitely try to use it. 

Here are a few popular API wrapper packages for APIs that you may have heard of (see Chapter \@ref(api-resources) for more):

* [`rtweet`](https://rtweet.info) - on [CRAN](https://CRAN.R-project.org/package=rtweet), on [GitHub](https://github.com/mkearney/rtweet)
* [`gutenbergr`](https://docs.ropensci.org/gutenbergr/) - on [CRAN](https://CRAN.R-project.org/package=gutenbergr) - on [GitHub](https://github.com/ropensci/gutenbergr)
* [`gistr`](https://docs.ropensci.org/gistr/) - on [CRAN](https://CRAN.R-project.org/package=gistr), on [GitHub](https://github.com/ropensci/gistr)

### Exploring Headcount of Homeschooled Children in British Columbia with `bcdata` {#bcdata}

The [British Columbia Data Catalogue](https://catalogue.data.gov.bc.ca/dataset) contains thousands of B.C. government datasets that are available under the [Open Government License - British Columbia](https://www2.gov.bc.ca/gov/content/data/open-data/open-government-licence-bc). From searching "B.C. Data Catalogue CRAN" on google I found an R package called [`bcdata`](https://bcgov.github.io/bcdata/) (on [GitHub](https://github.com/bcgov/bcdata)) that is a wrapper for the B.C. Data Catalogue.

The record that we will explore is the ["Headcount of Homeschool Children"](https://catalogue.data.gov.bc.ca/dataset/headcount-of-homeschooled-children), which contains data about the number of homeschool children in B.C. registered between 1991 and 2018. Our end goal is to visualize how the headcounts varies between male and female students across all of B.C. over the school years. The first step is to get the data into R. We can use the `bcdata` wrapper package to help us with this.

Install the package from GitHub (only do once)...

```r
library(remotes)
remotes::install_github("bcgov/bcdata")
```

...and then load it.

```{r}
library(bcdata)
```

The `bcdata` [website](https://bcgov.github.io/bcdata/) gives an overview of the main functions in the package. The ones that we will use are:

* `bcdc_browse()` - to browse the B.C. Data Catalogue (opens in your default browser)
* `bcdc_get_record()` - returns the catalogue record
* `bcdc_get_data()` - get the data for a catalogue record

There is also a [Get Started](https://bcgov.github.io/bcdata/articles/bcdata.html) vignette that is a good starting point for getting familiar with this package. We wil loosely follow along with this vignette to get the "Headcount of Homeschool Children" record data. 

First, we will use the [`bcdc_browse()`](https://bcgov.github.io/bcdata/reference/bcdc_browse.html) function to open up the B.C. Data Catalogue in our browser and find the webpage for the "Headcount of Homeschool Children" record.

```r
bcdc_browse()
```
You can filter the results by format type (e.g. .csv, .xls) and also search for keywords. Searching for "homeschool" will lead us to the "Headcount of Homeschooled Children" record [page](https://catalogue.data.gov.bc.ca/dataset/headcount-of-homeschooled-children). 

Under the Data and Resources section on this page we can see that there are six files available. Let's figure out how to get the first csv into R. 

We can use `bcdc_get_data()` to pull down the file into R. Take a look at the documentation for this function [here](https://bcgov.github.io/bcdata/reference/bcdc_get_data.html) or by typing `?bcdc_get_data` in your console. 

This function has one required argument, `record`, which can be the output of `bcdc_get_record()`, the resource name or ID as a string, or the resource URL. Let's use the resource URL. 

On the record [webpage](https://catalogue.data.gov.bc.ca/dataset/headcount-of-homeschooled-children) there is a "Show the Permalink" button. [Permalink](https://en.wikipedia.org/wiki/Permalink) is short for permanent link and is exactly what it sounds like: a link that will most likely not change. If you click on this button it will change the url to the permalink: `https://catalogue.data.gov.bc.ca/dataset/d378b0ba-6fa2-4f7f-a08c-97c697979ec3`. Save this as a string called `url`.

```{r}
url <- "https://catalogue.data.gov.bc.ca/dataset/d378b0ba-6fa2-4f7f-a08c-97c697979ec3"
```

We aren't quite ready to run `bcdc_get_data()` yet, however. There is also an optional argument, `resource`, which is used for cases when a record has multiple files available. Our record has six files available so we will definitely need to supply a `resource` argument. In the examples section of the [`bcdc_get_data()` documentation](https://bcgov.github.io/bcdata/reference/bcdc_get_data.html) we see that the resource ID is what we need to pass to `resource`. 

Where do we get the resource ID from? This isn't quite clear in the `bcdc_get_data()` documentation so we might need to explore a bit. Let's start by looking at the `bcdc_get_record()` function that was mentioned earlier. 

Take a look at the documentation for `bcdc_get_record()` [here](https://bcgov.github.io/bcdata/reference/bcdc_get_record.html) or by typing `?bcdc_get_record` in your console. It takes one argument, `id`, which can be the record URL. Let's pass it the permalink url that we saved earlier and see what we get back.

```{r}
bcdc_get_record(url)
```

This has the information that we were looking for! It lists six resources in total, the first one is a csv file called `Headcount_Homeschool`. This is the one we want. The resource ID is listed under "resource".

```
1) Headcount_Homeschool
     format: csv 
     url: https://catalogue.data.gov.bc.ca/dataset/d378b0ba-6fa2-4f7f-a08c-97c697979ec3/resource/409faf5a-7bf9-4d3f-baf6-758e0892a9c6/download/headcount_homeschool.csv 
     resource: 409faf5a-7bf9-4d3f-baf6-758e0892a9c6
     available in R via bcdata:  TRUE 
     code: bcdc_get_data(record = 'd378b0ba-6fa2-4f7f-a08c-97c697979ec3', resource = '409faf5a-7bf9-4d3f-baf6-758e0892a9c6')
```

Copy-and-paste the resource ID and save it as a string called `resource_id`.

```{r}
resource_id <- "409faf5a-7bf9-4d3f-baf6-758e0892a9c6"
```

Now we are ready to call `bcdc_get_data()` and read in the csv file.

```{r}
homeschool_data <- bcdc_get_data(record = url, resource = resource_id)
```

Yikes. We get a warning saying that there were 14,750 parsing failures. Only the first five parsing failures are printed out here but we can see that the failures started at row 2,974. It looks like a some of the failures occured because a logical (TRUE/FALSE) was expected but the actual row value was an integer or a string. 

The output told us that it was using `readr::read_csv()` to read in the file. From previous use I know that `read_csv()` has an argument called `guess_max`, which is the maximum number of rows that are used to guess the column type (we haven't covered this so don't worry if this is uncharted territory for you). Remember that our parsing failures started at row 2,974, so let's see if setting `guess_max = 3000` helps.

How do we pass `guess_max = 3000` to the `readr::read_csv()` call?

Let's go back to the `bcdc_get_data` documentation ([here](https://bcgov.github.io/bcdata/reference/bcdc_get_data.html) or by typing `?bcdc_get_data` in your console). 

Under the Arguments section we learn that `...` corresponds to arguments that are passed to the function that handles reading in the data file so we can just add `guess_max = 3000` as a third argument to our `bcdc_get_data()` call.  

```{r}
homeschool_data <- bcdc_get_data(record = url, resource = resource_id, guess_max = 3000)
```

No parsing failures! Now let's check out this data.

```{r message = FALSE}
library(dplyr)
glimpse(homeschool_data)
```

To find out what the column names mean we need to examine the original [record webpage](https://catalogue.data.gov.bc.ca/dataset/headcount-of-homeschooled-children) to locate the data dictionary. The data dictionary is [here](https://catalogue.data.gov.bc.ca/dataset/headcount-of-homeschooled-children/resource/aa05b182-e655-4b0f-8da6-af954b374c79). 


The `DATA_LEVEL` column specifies whether an observation is at the district-, province-, or school-level. The possible values are "PROVINCE LEVEL", "DISTRICT LEVEL", and "SCHOOL LEVEL". We want to look at headcounts across all of B.C. so we need to filter out data to only keep the observations that are at the province-level.

```{r}
homeschool_province <- homeschool_data %>% 
  filter(DATA_LEVEL == "PROVINCE LEVEL")

glimpse(homeschool_province)
```

From the data dictionary we also learn that the `PUBLIC_OR_INDEPENDENT` column splits the headcounts by whether the child was registered at a public school or an independent school. It has three values:

  * `BC Public School`
  * `BC Independent School`
  * `PROVINCE - Total` (the sum of the `BC Public School` and `BC Independent School` values)
  
We want to look at headcount differences between male and female, not between registration types, so let's filter our data and keep only the `PROVINCE - Total` rows. 

```{r}
homeschool_province2 <- homeschool_province %>% 
  filter(PUBLIC_OR_INDEPENDENT == "PROVINCE - Total") 

glimpse(homeschool_province2)
```

There are a few final things that we need to do before we can start plotting. The headcounts for males and females are in an un-tidy format. Let's reshape the data by using `tidyr::gather()` that we learned about in Chapter \@ref(tidy-data) to gather the `MALE_HOME_SCHOOL_COUNT` and `FEMALE_HOME_SCHOOL_COUNT` columns into `gender` and `headcount`. Then we will use `dplyr::case_when()` to rename `MALE_HOME_SCHOOL_COUNT` and `FEMALE_HOME_SCHOOL_COUNT` to `male` and `female` (we haven't used this function yet so don't worry if this is new territory for you, this is just to make things neater). 

```{r}
library(tidyr)

homeschool_tidy <- homeschool_province2 %>% 
  gather(MALE_HOME_SCHOOL_COUNT, FEMALE_HOME_SCHOOL_COUNT, key = "gender", 
         value = "headcount") %>% 
  mutate(gender = case_when(gender == "FEMALE_HOME_SCHOOL_COUNT" ~ "female",
                            gender == "MALE_HOME_SCHOOL_COUNT" ~ "male"))

glimpse(homeschool_tidy)
```

Great! Now let's plot the headcounts of homeschooled males and females over the school years.

```{r}
library(ggplot2)

ggplot(homeschool_tidy, aes(x = SCHOOL_YEAR, y = headcount, 
                            color = gender, group = gender)) +
  geom_point() +
  geom_line() +
  # clean up axis title and plot title
  labs(x = "School Year", y = "Total Homeschooled Children",
       title = "Headcounts of Homeschooled Children in British Columbia by Gender",
       caption = "Data Source: B.C. Data Catalogue") +
  # this changes the angle of the x axis labels 
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

Interesting, there were more male children than female children that were homeschooled in B.C. for all schools years except 1994/1995. The number of children homeschooled also peaked in the 1996/1997 school year and steadily decreased after. Maybe there was something that happened in 1996/1997 that sparked this decline.

If you want to keep going, try visualizing the headcounts of homeschooled children over the school years (regardless of gender) for registrations at Public School vs Independent Schools.

### Exploring US census data using `tidycensus` {#tidycensus}

The [`tidycensus`][tidycensus-web] package (on [CRAN][tidycensus-cran], on [GitHub][tidycensus-github]) is a wrapper package for two US Census Bureau APIs:

* [Decennial Census (1990, 2000, 2010) API](https://www.census.gov/data/developers/data-sets/decennial-census.html)
* [American Community Survey 5-Year Data (2009-2017) API](https://www.census.gov/data/developers/data-sets/acs-5year.html)

The authors have written a great vignette to help get you started with `tidycensus` [here](https://walkerke.github.io/tidycensus/articles/basic-usage.html).

First, let's install/load the package.
```{r message = FALSE}
#install.packages("tidycensus")
library(tidycensus)
```

To access the US Census Bureau APIs first we need to request a new API key here: <https://api.census.gov/data/key_signup.html>. Check your email and follow the instructions to activate your key.

Now that you have a personal API key, the next step is to add it to your .Renviron file. The `tidycensus` package has a helpful function called `census_api_key()` that will take care of this step for you but we can also do it ourselves with the `usethis` package.

```r
library(usethis)

usethis::edit_r_environ() # edit your user level.Renviron file.
```

This will open up your .Renviron file in a new tab. Add `CENSUS_API_KEY=<your-secret-api-key>` on a new line. Be sure to add a new line after this! <!--insert photo of RStudio default setting here--> 

Save the file and restart your R session. You can now access your key with `Sys.getenv("CENSUS_API_KEY")`. If you are using GitHub be sure to add `.Renviron` to your `.gitignore` file so you don't accidentally push the key that you just took the time to hide.

Let's try pulling in some data from the [1990 Decennial Census](https://www.census.gov/data/developers/data-sets/decennial-census.1990.html). We can check out the different variables for one of the datasets through the US Census Bureau [website](https://api.census.gov/data/1990/sf3/variables.html) or with `tidycensus::load_variables()`.

```{r eval = FALSE}
library(dplyr)

# what are the variables for the sf3 dataset for 1990?
variables_1990 <- load_variables(1990, "sf3")
glimpse(variables_1990)
```

Let's explore variables related to income. We can filter for labels that contain the string "income" by combining `stringr::str_detect()` with `dplyr::filter()`.
```{r eval = FALSE}
library(stringr)

variables_1990 %>% 
  mutate(label = str_to_lower(label)) %>%  # eliminate case sensitivity problems
  filter(str_detect(label, "income"))
```

What was the median household income in 1990 by state? Let's use `tidycensus::get_decennial()` to pull down the relevant data.
```{r eval = FALSE}
median_income <- get_decennial(geography = "state", variables = "P080A001", 
                               year = 1990) %>% 
  rename(state = NAME)

glimpse(median_income)
```

Hmm, there are 51 observations instead of 50. Maybe this is because they separated DC?
```{r eval = FALSE}
median_income %>% 
  mutate(state = str_to_lower(state)) %>% # eliminate case sensitivity problems
  filter(state %in% c("dc", "d.c.", "district of columbia")) # check a few variations
```
It looks like they did!

Let's try plotting.
```{r fig.width = 9, fig.height = 9,eval = FALSE}
library(ggplot2)

ggplot(median_income, aes(state, value)) +
  geom_point(color = "cornflowerblue", alpha = 0.8) +
  labs(x = "State", y = "Median Household Income", 
       title = "1990 US Decennial Census Data",
       subtitle = "Median Household Income by State",
       caption = "Data Source: https://www.census.gov") +
  scale_y_continuous(breaks = c(20000, 25000, 30000, 35000, 40000, 45000),
                     labels = c("$20,000", "$25,000", "$30,000", "$35,000",
                                "$40,000", "$45,000")) +
  coord_flip() +
  theme_minimal()
```

Whoops. Let's use `forcats::fct_reorder` to reorder the factor levels of `state` to make this plot easier to parse.
```{r eval = FALSE}
library(forcats)

median_income_ordered <- median_income %>% 
  mutate(state = fct_reorder(state, value))
```

```{r fig.width = 9, fig.height = 9, eval = FALSE}
ggplot(median_income_ordered, aes(state, value)) +
  geom_point(color = "cornflowerblue", alpha = 0.8) +
  labs(x = "State", y = "Median Household Income", 
       title = "1990 US Decennial Census Data",
       subtitle = "Median Household Income by State",
       caption = "Data Source: United States Census Bureau") +
  scale_y_continuous(breaks = c(20000, 25000, 30000, 35000, 40000, 45000),
                     labels = c("$20,000", "$25,000", "$30,000", "$35,000",
                                "$40,000", "$45,000")) +
  coord_flip() +
  theme_minimal()
```

The states with the highest median household income in 1990 were Connecticut, Alaska, and New Jersey while those with the lowest were Arkansas, West Virginia, and Mississippi. Is it what you were expecting to see?


## Interact with an API

In Chapter \@ref(api-wrappers) we experimented with several packages that "wrapped" APIs. That is, they handled the creation of the request and the formatting of the output. What do you do if you want to use an API in R that doesn't already have a wrapper package written for it? One option is using the `httr` package to help out with the HTTP requests and responses. 



### Exploring movies using the OMDb API


The [Open Movie Database](http://www.omdbapi.com) (OMDb) is an API for movies. <!--CC BY-NC 4.0--> Before we can interact with this API in R we need to request an API key. 

request a free API key (1,000 daily request limit) here: http://www.omdbapi.com/apikey.aspx



```{r links, child="links.md"}
```



