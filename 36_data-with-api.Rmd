# Using an API to get data {#use-api}

In the simplest case, the data that you want is already available on the internet in a familiar format such as a csv and you can use `readr::read_csv()` to load it directly into R.

Often times, however, things are a bit more complicated. You might need to go through an [**Application Programming Interface**](https://en.wikipedia.org/wiki/Application_programming_interface#Web_APIs) (API) to get the data that you want.

An API allows you (the client) to programmatically get resources (e.g. a csv file, html file, etc.) from a web server via a [**Hypertext Transfer Protocol**](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) (HTTP) request. It is essentially facilitating a conversation: you send the web server a request and then the server sends you back a response. This response can either be the data you asked for or an error message.

![Image Source: [What exactly IS an API?](https://medium.com/@perrysetgo/what-exactly-is-an-api-69f36968a41f)  by Perry Eising](img/api-diagram.png)

If an API is popular, it might have an API wrapper package that will handle the HTTP part for you. If not, then you will need to handle the HTTP part yourself. This isn't as bad as it may seem! The [`httr`][httr-web] package (on [CRAN][httr-cran], on [GitHub][httr-github]) can help make this easier.

If you are interested in learning more about APIs and HTTP check out Chapter \@ref(api-resources) for some good places to start.


## Install-and-play {#api-wrappers}

Many popular APIs have helper R packages that "wrap" around the original API. These packages generally will have functions that assist with formatting a query, sending the query to the web server, and parsing the response sent back.

The first thing that you should do if you're planning on using an API to get data is to see if there is already an API wrapper package that exists. Try searching the API name on CRAN and GitHub. If there is an API wrapper package available, you should definitely try to use it. 

Here are a few popular API wrapper packages for APIs that you may have heard of (see Chapter \@ref(api-resources) for more):

* [`rtweet`](https://rtweet.info) for the Twitter API (on [CRAN](https://CRAN.R-project.org/package=rtweet), on [GitHub](https://github.com/mkearney/rtweet))
* [`gutenbergr`](https://docs.ropensci.org/gutenbergr/) for Project Gutenberg's API (on [CRAN](https://CRAN.R-project.org/package=gutenbergr), on [GitHub](https://github.com/ropensci/gutenbergr))
* [`gistr`](https://docs.ropensci.org/gistr/) for GitHub gists (on [CRAN](https://CRAN.R-project.org/package=gistr), on [GitHub](https://github.com/ropensci/gistr))

### Exploring Density Data on Dryad Digital Repository with `rdryad` {#dryad-wood}

<!--There is a note attached to this dataset asking that Lopez-Gonzalez be notified if the dataset is used in publication--> 

The [Dryad Digital Repository](https://datadryad.org) contains datasets from scientific publications that are available to download and explore. From searching "Dryad Digital Repository R package" on google I found the [`rdryad`][rdryad-web] package (on [CRAN][rdryad-cran], on [GitHub][rdryad-github]) that is a wrapper for the Dryad Digital Repository API.

The dataset that we will explore is the [Global wood density database](https://datadryad.org/resource/doi:10.5061/dryad.234/1), which is data from a [paper](https://onlinelibrary.wiley.com/doi/full/10.1111/j.1461-0248.2009.01285.x) that was published in 2009:

> Chave J, Coomes DA, Jansen S, Lewis SL, Swenson NG, Zanne AE (2009) Towards a worldwide wood economics spectrum. Ecology Letters 12(4): 351-366. https://doi.org/10.1111/j.1461-0248.2009.01285.x

The dataset contains the wood density (g/cm^3) values for over 16,000 samples of trees from various regions around the world. Let's pull down the dataset into R using the `rdryad` package and check out the distribution of the wood density values for trees in Australia, Europe, India, Madagascar, and Mexico.

The first step is to install/load the `rdryad` package.
```{r message = FALSE}
#install.packages("rdryad")
library(rdryad)
```

We will use two functions from `rdryad`: [`dryad_files()`](https://docs.ropensci.org/rdryad/reference/dryad_files.html) and [`dryad_fetch()`](https://docs.ropensci.org/rdryad/reference/dryad_fetch.html). 

`dryad_files()` requires one argument, `doi`, the DOI ([Digital Object Identifier](https://en.wikipedia.org/wiki/Digital_object_identifier)) for a Dryad dataset as a string. The `doi` needs to have the form "10.5061/dryad.xxx". It returns a url that can be used to download the dataset.

`dryad_fetch()` requires one argument, `url`, which is the output of `dryad_files()`. When called it will download the dataset located at the url and saves it as a temporary file. It returns a named list where the name corresponds to the url and the value corresponds to the temporary file location.

We can find the DOI for the for the dataset we're interested on the [webpage for the record](https://datadryad.org/resource/doi:10.5061/dryad.234/1). Next to DOI is "https://doi.org/10.5061/dryad.234/1". This is not quite the format that `dryad_files()` requires so let's change this to "10.5061/dryad.234". Pass it to `dryad_files()` to get the download url for the dataset.

```{r}
wood_url <- dryad_files(doi = "10.5061/dryad.234")
wood_url
```

Great! Now let's use `dryad_fetch()` to download the dataset into a temporary file.

```{r}
fetch_output <- dryad_fetch(url = wood_url)
fetch_output
```

I'm going to pull out the file path and save it as `file_path` just to make things cleaner.
```{r}
file_path <- fetch_output[[1]]
file_path
```

All that's left now is to read in the temporary file into R. The [webpage for the record](https://datadryad.org/resource/doi:10.5061/dryad.234/1) tells us that the file is an xls file. We can use the `read_xls()` function from the [`readxl`][readxl-web] package (on [CRAN][readxl-cran], on [GitHub][readxl-github]) to load the file into R. Before that, however, let's use the `excel_sheets()` function from the same package to find out how many sheets there are. 

```{r}
library(readxl)

excel_sheets(file_path)
```

There are three sheets in the file. Let's load in the sheet called "Data" by including `sheet = "Data"` when calling `read_xls`.
```{r}
wood_data <- read_xls(file_path, sheet = "Data")
```

Now let's check out what we have!
```{r message = FALSE}
library(dplyr)
glimpse(wood_data)
```

Yikes, those columns names are pretty messy. I'm going to use the [`clean_names()`](https://www.rdocumentation.org/packages/janitor/versions/1.2.0/topics/clean_names) function from the [`janitor`](janitor-web) package (on [CRAN][janitor-cran], on [GitHub][janitor-github]) to help tidy these up. `clean_names()` takes a data frame and returns it with the column names cleaned up. The column names are changed to [Snake case][wiki-snake-case] by default, but you can change this with the `case` argument. Check out the [`clean_names()`](https://www.rdocumentation.org/packages/janitor/versions/1.2.0/topics/clean_names) documentation to see all the possible values for `case`. For now, let's just stick with snake case.

```{r message = FALSE}
#install.packages("janitor")
library(janitor)

wood_data <- wood_data %>% 
  clean_names()

glimpse(wood_data)
```

So much better! Next, let's filter the data so we only keep observations that are in Australia, Europe, India, Madagascar, and Mexico. We can do this by using `filter()` from `dplyr` on the `region` column. 

Matching for so many values would require a lot of repetitions of `filter(region == __)`. We can do the same thing by using the `%in%` operator. To use it here let's first save all of the `region` values that we want to keep as a vector called `region_values`. Now we can filter for rows where `region` matches any one of the values in `region_values` with `region %in% region_values`. You can pull up the documentation for `%in%` by calling ```` ?`%in%` ```` in your console. 

Here is the `%in%` operator in action:
```{r}
region_list <- c("Australia","Europe", "India", "Madagascar", "Mexico")

wood_filtered <- wood_data %>% 
  filter(region %in% region_list)
```

Now let's visualize the distribution of wood density values of by using the `geom_boxplot()` layer in `ggplot2`.

```{r}
library(ggplot2)

ggplot(wood_filtered, aes(region, wood_density_g_cm_3_oven_dry_mass_fresh_volume)) +
  geom_boxplot() +
  labs(x = "Region", y = "Wood Density (g/cm^3)", 
       title = "Distributions of Wood Density Values for Trees in 5 Countries",
       caption = "Data Source: https://doi.org/10.5061/dryad.234")
```

It looks like the trees in Australia had the highest mean wood density while the trees in Europe had the lowest mean wood density. If you want to keep going try visualizing the distribution of wood density values for other regions included in the dataset.


### References

Chave J, Coomes DA, Jansen S, Lewis SL, Swenson NG, Zanne AE (2009) Towards a worldwide wood economics spectrum. Ecology Letters 12(4): 351-366. https://doi.org/10.1111/j.1461-0248.2009.01285.x

Zanne AE, Lopez-Gonzalez G, Coomes DA, Ilic J, Jansen S, Lewis SL, Miller RB, Swenson NG, Wiemann MC, Chave J (2009) Data from: Towards a worldwide wood economics spectrum. Dryad Digital Repository. https://doi.org/10.5061/dryad.234



## Interact with an API {#api-query}

In Chapter \@ref(api-wrappers) we experimented with several packages that "wrapped" APIs. API wrapper packages handle the creation of the request and the parsing of the output. What do you do if you want to use an API in R that doesn't already have a wrapper package written for it? One option is using the [`httr`][httr-web] package (on [CRAN][httr-cran], on [GitHub][httr-github]) to help out with the HTTP requests and responses. 

The [Getting started with `httr`](https://httr.r-lib.org/articles/quickstart.html) vignette is a good place to start if you haven't used the `httr` package before. 

The main functions in `httr` that we will be using are:

* [`GET()`](https://httr.r-lib.org/reference/GET.html) - sends a request to a `url` with `config` settings that you specify and returns a `response` object
* [`content()`](https://httr.r-lib.org//reference/content.html) - returns the body of a response object (more on this later)

A `response` object contains all of the information associated with a request. You can pull up the documentation for `response` by calling `?response` in your console. Some of the fields that a `response` object will have include:

* `url` - where the request was sent (i.e. the url passed to `GET()`)
* `status_code` - the HTTP status code request/response
* `header` - a named list of the headers in the response 

We will talk more about the specifics of all of this when we walk through an example of using `httr` to query the [Open Movie Database](http://www.omdbapi.com) (OMBD) API in the following section.

Before that, however, there is one more layer to querying an API that we need to address: the format of the response sent back by the web server. A good API wrapper package will spare you the pain of parsing the response and hand you the data all neat and cleaned up. We won't be as lucky this time around. 

The two most common formats that you will encounter are [JSON](https://www.json.org) and [XML](https://en.wikipedia.org/wiki/XML), which stand for JavaScript Object Notation and Extensible Markup Language respectively. JSON is a ["lightweight data-interchange format"](https://www.json.org) and XML is a data format and also a markup language. Both are used to store and transfer data on the web. There is the [`jsonlite`][jsonlite-cran] package for handling JSON in R and the [`xml2`][xml2-web] package for handling XML in R.

We will be focusing mainly on XML in this chapter but I recommend starting with [JSON vs XML](https://restfulapi.net/json-vs-xml/) and [json.org](https://www.json.org) to learn more about both. 

Next up: using `httr` to query the [Open Movie Database](http://www.omdbapi.com) (OMBD) API and `xml2` to parse the response.

### Getting movie data with the OMDb API

The [Open Movie Database](http://www.omdbapi.com) (OMDb) is an API that you can use to get data about movies and movie posters. <!--CC BY-NC 4.0-->We won't be using an API wrapper package to get data via this API so we will need to read the OMDb documentation to find out how to use it. 

We will use the `httr` package query the OMDb API for the movie poster and movie data for the film Harry Potter and the Chamber of Secrets (2002). 

Looking through [omdbapi.com](http://www.omdbapi.com) we find out that in order to interact with this API we will need to request an API key. An API key is used to track how an API is being used. It is a secret, unique identifier that is associated with a request(s). They are often used to limit the number of requests that someone is sending. For example, the OMDb API has a 1,000 daily request limit. You can read more about API keys in the `httr` vignette [Managing secrets](https://httr.r-lib.org/articles/secrets.html).

Request a free API key for the OMDb API here: <http://www.omdbapi.com/apikey.aspx> 

Check your email and follow the instructions to activate your key. This email should include your key, which will be a mix of letters and digits.

Now that you have an API key, the next step is to put it somewhere that you (or an API wrapper package, etc.) can access. Your API key should be kept secret so we need make sure we put it somewhere safe. One option is to stash it in your .Renviron file. Be sure to save it as something memorable, like `OMDB_API_KEY`. You can use the `edit_r_environ()` function from the `usethis` package to add it to your `.Renviron` file.

```r
library(usethis)

usethis::edit_r_environ() # edit your user level.Renviron file.
```
This will open up your .Renviron file in a new tab. Add `OMDB_API_KEY=<your-secret-api-key>` on a new line (be sure to add a new line after this).

Save the file and restart your R session (Session -> Restart R). You can now access your key whenever you want by calling `Sys.getenv("OMDB_API_KEY")`. __Note!__ If you are using GitHub you may want to add `.Renviron` to your `.gitignore` file so you don't accidentally push the key that you just took the time to hide.

Now that we got the setting up the API key out of the way we can use the `httr` package to help with the next part. First, install/load in the `httr` package.

```{r}
#install.packages("httr")
library(httr)
```

We will use the `GET()` function from `httr` to format and send our request to the OMDb API. Check out the documentation for `GET()` [here](https://httr.r-lib.org/reference/GET.html) or by calling `?GET` in your console.

[This](https://httr.r-lib.org/articles/quickstart.html#the-request) section of the [Getting started with `httr`](https://httr.r-lib.org/articles/quickstart.html) vignette does a good job explaining how to use `GET()` to make a request. I recommend taking a quick look through it before continuing.

To use `GET()` here we will need to specify the `url` and `query` arguments. The `url` is the url that `GET()` should use to call the API as a string. `query` is a named list of the query parameters that `GET()` should include in our request. 

To figure out the values of `url` and `query` that we should use we need to return to the [OMDb documentation](http://www.omdbapi.com). Under "Usage" we learn that data requests should be sent to: `http://www.omdbapi.com/?apikey=[yourkey]&`. We are going to include our API key in the query parameters later so this url becomes: `http://www.omdbapi.com/`. Let's save this as `omdb_url`. 

```{r}
omdb_url <- "http://www.omdbapi.com/"
```

We also learn in the "Usage" section that we can ask for request data for a specific movie by setting the parameter `t` to the title and `y` to the year it was released.

Now we can create a named list called `query_params` with each parameter key-value pair to pass to `GET()`. This list will include the title (`t`), the year released (`y`), and our API key (`apikey`).

```{r}
query_params <- list(t = "Harry Potter and the Chamber of Secrets", 
                     y = "2002", apikey = Sys.getenv("OMDB_API_KEY"))
```

Let's try calling `GET()`.

```{r}
response <- GET(url = omdb_url, query = query_params)
```

This gives us the `response` object that I mentioned earlier. One of the fields that it includes is a `status_code`. We can use the [`http_status()`](https://www.rdocumentation.org/packages/httr/versions/1.4.0/topics/http_status) function from `httr` to get the HTTP status code. It takes a response object as input.

```{r}
http_status(response)
```

The HTTP status code is 200, meaning that the request was successful! 

We can use the [`content()`](https://www.rdocumentation.org/packages/httr/versions/1.4.0/topics/content) to extract and parse the actual body of the response that was sent back.
```{r}
response_parsed <- content(response)

str(response_parsed)
```

Let's check out what there is under Plot. 
```{r}
response_parsed$Plot
```

There also is a link to the movie poster under Poster
```{r}
poster_url <- response_parsed$Poster
poster_url
```

We can download this file and save it locally using `download.file()` (from the pre-loaded `utils` package) by specifying the url of the file and where we want it to be saved using `destfile`. 

```r
download.file(url = poster_url,
              destfile = "img/harry-potter-poster.jpg")
```


![](img/harry-potter-poster.jpg)

Next try getting the movie posters for the next Harry Potter film in the series, Harry Potter and Prisoner of Azkaban (2004). Then try writing a function that will get the movie posters for all of the films in the Harry Potter series.

```{r links, child="links.md"}
```



